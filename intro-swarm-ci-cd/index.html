<!DOCTYPE html>
<html>

<head>
  <title>Title</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body {
      font-family: 'Droid Serif';
      background: #272822;
    }

    h1,
    h2,
    h3 {
      font-family: 'Yanone Kaffeesatz';
      font-weight: 400;
      margin-bottom: 0;
      line-height: 120%;
    }

    .remark-slide-container {
      background: #272822;
    }

    .remark-slide-scaler {
      -webkit-box-shadow: none;
      box-shadow: none;
    }

    .remark-slide-content h1 {
      font-size: 3em;
    }

    .remark-slide-content h2 {
      font-size: 2em;
    }

    .remark-slide-content h3 {
      font-size: 1.6em;
    }

    .footnote {
      position: absolute;
      bottom: 3em;
    }

    li {
      padding: 8px 0;
    }

    li p {
      line-height: 1.25em;
    }

    .red {
      color: #fa0000;
    }

    .large {
      font-size: 2em;
    }

    a,
    a>code {
      color: #545dd0;
      text-decoration: none;
    }

    code {
      border: 1px solid #e7e8e2;
      border-radius: 5px;
      font-size: 0.9em;
      padding: 0 4px;
      margin: 0 4px;
    }

    h1 code {
      padding: 0 8px;
      margin: 0 8px;
    }

    .remark-code {
      display: block;
      padding: 8px 16px;
    }

    .remark-inline-code {
      display: inline-block;
    }

    .remark-code,
    .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }

    .remark-code-line-highlighted {
      background-color: #373832;
    }

    .pull-left {
      float: left;
      width: 47%;
    }

    .pull-right {
      float: right;
      width: 47%;
    }

    .pull-right~p {
      clear: both;
    }

    #slideshow .slide .content code {
      font-size: 0.8em;
    }

    #slideshow .slide .content pre code {
      font-size: 0.9em;
      padding: 15px;
    }

    .inverse {
      background: #272822;
      color: #777872;
    }

    .inverse h1,
    .inverse h2 {
      color: #f3f3f3;
    }

    /* Slide-specific styling */

    #slide-inverse .footnote {
      bottom: 12px;
      left: 20px;
    }

    #slide-how .slides {
      font-size: 0.9em;
      position: absolute;
      top: 151px;
      right: 140px;
    }

    #slide-how .slides h3 {
      margin-top: 0.2em;
    }

    #slide-how .slides .first,
    #slide-how .slides .second {
      padding: 1px 20px;
      height: 90px;
      width: 120px;
      -moz-box-shadow: 0 0 10px #777;
      -webkit-box-shadow: 0 0 10px #777;
      box-shadow: 0 0 10px #777;
    }

    #slide-how .slides .first {
      background: #fff;
      position: absolute;
      top: 20%;
      left: 20%;
      z-index: 1;
    }

    #slide-how .slides .second {
      position: relative;
      background: #fff;
      z-index: 0;
    }

    /* Two-column layout */

    .left-column {
      color: #777;
      width: 20%;
      height: 92%;
      float: left;
    }

    .left-column h2:last-of-type,
    .left-column h3:last-child {
      color: #000;
    }

    .right-column {
      width: 75%;
      float: right;
      padding-top: 1em;
    }
    
    #source {
      display: none;
    }
  </style>
</head>

<body>
  <textarea id="source">

layout: true
class: middle, inverse

---

# Introduction to Orchestration and Continuous Integration with Docker Swarm

--

[p.2hog.codes/intro-swarm-ci-cd](https://p.2hog.codes/intro-swarm-ci-cd)

---

# About 2hog.codes

* Founders of [SourceLair](https://www.sourcelair.com) online IDE + Dimitris Togias
* Docker and DevOps training and consulting

---

# Antonis Kalipetis

* Docker Captain and Docker Certified Associate
* Python lover and developer
* Technology lead at SourceLair / stolos.io
* Docker training and consulting

.center[I love automating stuff and sharing knowledge around all things containers, DevOps and optimizing developer workflows.]

.footnote[[@akalipetis](https://twitter.com/akalipetis)]

---

# Paris Kasidiaris

* Python lover and developer
* CEO at SourceLair, Private Company
* Docker training and consulting

.footnote[[@pariskasid](https://twitter.com/pariskasid)]

---

# Dimitris Togias

* Self-luminous, minimalist engineer
* Co-founder of Warply and Niobium Labs
* Previously, Mobile Engineer and Craftsman at Skroutz

.footnote[[@demo9](https://twitter.com/demo9)]

---

# Agenda

1. What is Docker Swarm?
1. How to get from development to production
1. Continuous integration and deployment

---

# What is Docker Swarm?

---

# Stop using nodes, start using clusters

???

* We talked about running Docker containers in a single node, but we need more for production
* Swarm takes care of managing your whole cluster
* You don't have to know the health of each node any more
* Start knowing the health of your services

---

# Key concepts

--

* Nodes
  * The servers in your cluster, either managers or workers
* Services
  * A group of tasks that share the same configuration
* Tasks
  * Mapped 1-1 with containers, but could be any deployable unit

---

layout: true
class: middle

---

# Topology Docker Engine

.center[![:scale 50%](images/docker-engine-topology.png)]

---

# Swarm roles

---

# Swarm roles

.left-column[
## Managers
]

.right-column[
* Use Raft Consensus Algorithm
* Are responsible for applying the declarative state in the cluster
* M-TLS, encrypted on operation
  * Optionally encrypted at rest
* Should direct to them in order to manage the cluster
* Can run payload, but should be avoided in bigger clusters
]

---

# Swarm roles

.left-column[
## Managers
## Workers
]

.right-column[
* Only run payload within a cluster, when directed by managers
* Are responsible for applying the declarative state in the cluster
* M-TLS communication with managers
* Wait for payload to be pushed to them
* Only have access to the resources assigned to them
]

???

* Have cryptographic identity
* Minimal threat-model, as they do not have access to things like secrets if they're not assigned to them
* Only have access to the payload sent to them, aka registry secrets, etc

---

# Topology Docker Swarm

.center[![:scale 80%](images/swarm-topology.png)]

---

layout: true
class: middle, inverse

---

# Let's create our first Docker Swarm

--

[labs.play-with-docker.com](http://labs.play-with-docker.com)

---

# Create a new Swarm

--

```bash
[node1] (local) root@10.0.74.3 ~
$ docker swarm init --advertise-addr=eth0
```

---

.center[# Join another node in the Swarm as worker]

--

```bash
[node2] (local) root@10.0.74.4 ~
$ docker swarm join --token SWMTKN-1-XXX 10.0.74.3:2377
```

---

# Join another node in the Swarm as manager

--

```bash
[node1] (local) root@10.0.74.3 ~
$ docker swarm join-token manager
```

???

* They can try to get the token from a worker, which will not work
* Help them understand the importance of the manager

--

```bash
[node3] (local) root@10.0.74.5 ~
$ docker swarm join --token SWMTKN-1-YYY 10.0.74.3:2377
```

---

# List the nodes in your cluster

.left[
```bash
[node3] (local) root@10.0.74.5 ~
$ docker node ls
```
]

--

.left[
```bash
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
vz22xh8zj1xjouflm9rlnfhxu     node1               Ready               Active              Leader
ec0eypoz0o6btv77uyjqux1l9     node2               Ready               Active
hguvzetdq838qseegng6n58ow *   node3               Ready               Active              Reachable
```
]

---

# Let's destroy everygthing, kill the daemon in one node

--

.left[
```bash
[node3] (local) root@10.0.74.5 ~
$ kill -9 $(cat /var/run/docker.pid)
```
]

--

.left[
```bash
[node1] (local) root@10.0.74.3 ~
$ docker node ls
```
]

???

* 2 managers is a bad idea, you always need N / 2 + 1 for concensus
* let's increase the managers

---

# Let's restore the node

--

.left[
```bash
[node3] (local) root@10.0.74.5 ~
$ dockerd 2> /dev/null &
```
]

---

# Let's promote node2 to manager

--

.left[
```bash
[node3] (local) root@10.0.74.5 ~
$ docker node promote node2
```
]

--

.left[
```bash
[node3] (local) root@10.0.74.5 ~
$ docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
vz22xh8zj1xjouflm9rlnfhxu     node1               Ready               Active              Leader
ec0eypoz0o6btv77uyjqux1l9     node2               Ready               Active              Reachable
hguvzetdq838qseegng6n58ow *   node3               Ready               Active              Reachable
```
]

---

# Let's destroy everygthing, again

--

.left[
```bash
[node3] (local) root@10.0.74.5 ~
$ kill -9 $(cat /var/run/docker.pid)
```
]

--

## or not...

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
vz22xh8zj1xjouflm9rlnfhxu *   node1               Ready               Active              Leader
ec0eypoz0o6btv77uyjqux1l9     node2               Ready               Active              Reachable
hguvzetdq838qseegng6n58ow     node3               Ready               Active              Unreachable
```
]

???

* Now even though we have 2 managers, even if one goes down the cluster is umanageable
* We need at least 3 to make sure we have HA

---

# Deploying services to Docker Swarm

???

* Services are the definition of the state that we want the cluster to move in
* From services, tasks are created

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ docker service create --publish=8080:80 --nane=nginx nginx:latest
```
]

--

## Now click on the port in the UI

???

* No matter which node you are in, the port opens
* This is because Docker Swarm have ingress load balanacing

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```
]

---

# Docker load-balancing

--

* Each service in the Swarm gets a virtual IP
  * The Swarm makes sure connections to this internal IP are routed to the correct container, in any host in the Swarm
* Multi-host networking is made with pluggable network drivers
* If desired, a port is opened to each node of the Swarm
  * Connections to this port are routed to the service virtual IP, at a defined port

???

Benefits:
* You don't need to know where in the cluster every service runs
* You don't need to do health management

---

# Updating the service

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ docker service update --image=nginx:does-not-exists nginx
```
]

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ docker service ps nginx
ID                  NAME                IMAGE                   NODE                DESIRED STATE       CURRENT STATE             ERROR                           PORTS
z38051h4kf4t        nginx.1             nginx:does-not-exists   node2               Ready               Rejected 4 seconds ago    "No such image: nginx:does-not…"
yadhc69tuauz         \_ nginx.1         nginx:does-not-exists   node1               Shutdown            Rejected 9 seconds ago    "No such image: nginx:does-not…"
xwxtx6fc5hmp         \_ nginx.1         nginx:does-not-exists   node1               Shutdown            Rejected 13 seconds ago   "No such image: nginx:does-not…"
ov5i7c5y71zc         \_ nginx.1         nginx:latest            node1               Shutdown            Shutdown 9 seconds ago
```
]

---

# Rolling back

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ docker service rollback nginx
```
]

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~$ docker service ps nginx
ID                  NAME                IMAGE                   NODE                DESIRED STATE       CURRENT STATE                 ERROR                              PORTS
hak9ijaaubgi        nginx.1             nginx:latest            node1               Running             Running 11 seconds ago
yylxs4ktx0ab         \_ nginx.1         nginx:does-not-exists   node2               Shutdown            Rejected 49 seconds ago       "No such image: nginx:does-not…"
yy1z6lb6rqsm         \_ nginx.1         nginx:does-not-exists   node1               Shutdown            Rejected about a minute ago   "No such image: nginx:does-not…"
z38051h4kf4t         \_ nginx.1         nginx:does-not-exists   node2               Shutdown            Rejected about a minute ago   "No such image: nginx:does-not…"
yadhc69tuauz         \_ nginx.1         nginx:does-not-exists   node1               Shutdown            Rejected about a minute ago   "No such image: nginx:does-not…"
[node1] (local) root@10.0.16.3 ~
```
]

---

# Securely storing secrets

--

* Manage sensitive data within containers
* Database passwords, SSH keys, TLS certificates

---

# Secrets security
* Cryptographically stored inside the Raft log
* Mounted as an in-memory filesystem to the container
  * Available only to the node that the payload runs
  * Cannot be found in the disk
  * Seen as file within the container

???

* Environment variables leak
* Minimum attack vector

---

# Let's see this in an example

--

```bash
[node1] (local) root@10.0.6.3 ~
$ docker secret create some-sec -
```

???

* Create a new secret using stdin

--

```bash
[node1] (local) root@10.0.6.3 ~
$ docker service create --secret=some-sec --workdir=/run/secrets --pubilsh=8888:8000 python:3.6 python -m http.server 8000unknown flag: --pubilsh
```

???

* Click the port in the UI, to see the secrets

---

# Configuring services

* Docker configs allow you to store configuration inside the Swarm cluster
* Like secrets, but can be retrieved and mounted to any path

---

# Create a new config


```bash
[node1] (local) root@10.0.16.3 ~
$ cat << EOF > index.html
<html>
  <head><title>Hello Docker</title></head>
  <body>
    <p>Hello Docker! You have deployed a HTML page.</p>
  </body>
</html>
EOF
```

--

```bash
[node1] (local) root@10.0.16.3 ~
$ docker config create homepage index.html
```

--

```bash
[node1] (local) root@10.0.16.3 ~
$ docker service create --config=source=homepage,target=/usr/share/nginx/html/index.html --publish=9999:80 nginx
```

---

# From services to stacks

???

* Services are orchestrated containers
* Stacks are orchestrated Docker Compose files

--

.left[
```bash
[node1] (local) root@10.0.16.3 ~
$ cat << EOF > stack.yml
version: '3.3'
services:
  nginx:
    image: nginx:alpine
    ports:
      - 9090:80
EOF
[node1] (local) root@10.0.16.3 ~
$ docker stack deploy -c stack.yml my-stack
```
]

---

# These look good, now what?

--

## The DevOps dream

---

# Getting from here

.center[![:scale 50%](images/before-devops.png)]

--

# To here

.center[![:scale 50%](images/after-devops.png)]

---

# Optimizing your delivery pipeline

.left[
* Same runtime in development, CI and production
* Use the same declarative format all the way
* Focus on what you do best
]

???

* Docker Compose works both in one node and Docker Swarm
* Developers should code
* Ops should manage infrastructure
* Application management is left to the Swarm


---

# Developing locally

--

* Use Docker Compose
  * Try to have a similar set of files for both development and production
* Get up and running quickly with Docker for Mac / Windows
  * This gives you the whole toolchain, Docker and Docker Compose
* Have a series of Dockerfile
  * For example Dockerfile and Dockerfile.dev that derives from Dockerfile

---

# Using Docker Compose override files

--

* Allows for same base file, adding some development tweeks
* No need to manage multiple files or repos
* Same stack definition for development and production

???

* Open the docker-compose.yml and docker-compose.override.yml files
* See how simple it is to override

---

# Continuous integration and deployment

--

* Make sure your software works as expected on every push
* Repeatable processes for deploying software in different environments
* Configuration as code, `.gitlab-ci.yml` file inside the repo

---

# GitLab CI

--

* GitLab CI creates jobs, which are run by agents
* Jobs are run either parallely, or sequentially
* Jobs can pass artifacts in the chain and can include a cahce

---

# Containerized jobs

* GitLab CI uses Docker images by default for the jobs
* We can go further though

--

## Build images and run tests against them

???

* 100% certainty that the deployable unit is correctly tested
* Same environment in development, testing and production

---

# Let's go through some GitLab CI pipeline examples

---

# Making everything work

--

1. Use Docker Compose for development
1. Use the same Docker Compose format for deploying to Swarm
1. Build images and deploy stacks with GitLab CI

---

class: center

# Thanks!

    </textarea>
  <script src="https://remarkjs.com/downloads/remark-latest.min.js">
  </script>
  <script>
    remark.macros.scale = function (percentage) {
      var url = this;
      return '<img src="' + url + '" style="width: ' + percentage + '" />';
    };
    var slideshow = remark.create({
      highlightStyle: 'monokai',
      highlightLines: true,
      ratio: '16:9',
    });
    slideshow.on('afterShowSlide', function (slide) {
      console.log(arguments);
    });
  </script>
</body>

</html>
